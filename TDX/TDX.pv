(* For using these artifacts, please cite the corresponding paper as follows: *)
(* Muhammad Usama Sardar, Thomas Fossati, and Simon Frost, SoK: Attestation in Confidential Computing, 2023, 
https://www.researchgate.net/publication/367284929_SoK_Attestation_in_Confidential_Computing *)

(* Author: Muhammad Usama Sardar *)
(* Contributions are welcome *)

(* Instructions to run: *)
(* Install ProVerif: see https://bblanche.gitlabpages.inria.fr/proverif/ for details*)
(* create a subfolder for results before executing *)
(* Then to execute: run as follows: *)
(* proverif -graph <subfolderNameForResults> TDX.pv *)
(* subfolder will contain the traces in .dot as well as .PDF *)

(* To run in interactive mode: *)
(* proverif_interact TDX.pv *)

(* Informal description of the protocol:
**********************************************************************
Assumptions: 
**********************************************************************
  a. secure channel between TD and TDX Module (by SoC)
  b. secure channel between TDX Module and CPU Hardware (by SoC)
  c. secure channel between TD QE and CPU Hardware (by SoC)
  d. secure channel between PCE and CPU Hardware (by SoC)
  e. Adversary has full control to create fake TDs and get its Quote. To model this, all Claims with corresponding Reference Values are obtained as input from adversary. 

**********************************************************************
Naming convention: 
**********************************************************************
  <var>_<entityName> for a variable received from another entity (<entityName>'s view of <var>)
  where <entityName> = {PCE, QE, TD, TDXM, CPU, Ver}

  XXsig = signed using key XX
  ZZRef = Reference Value for ZZ

  YY = Private key 
  pubYY or pub(YY) = Public part of key YY
  YY key-pair = both private and public parts 

Roles: PCE (PCK) | QE | TD | TDX Module | CPU HW (MK) | Verifier (pubIRK)
where | represents parallel composition (in contrast to || which is used for concatenation)
  and preconfigured keys are shown in parenthesis

Fields marked as "user-defined input" are user-defined.

**********************************************************************
Mapping for code symbols <-> terminology in Intel specs
**********************************************************************
Formatting: 2-space indentation represents sub-fields/sub-data structures
*Local Evidence*
* QE-PCE LA (init phase) *
QEReport = TDQE REPORT [source: Intel® 64 and IA-32 Architectures Software Developer's Manual, Sec. 35.16, Page 35-16 (4266), Vol. 3D (March 2023)]
  QEReportBody = QE Report Body
    CPUSVN = CPUSVN (This can be higher than the one in PCKcert; Intel does not issue PCKcert for all)
    misc = MISCSELECT
    cetAtt = CET_ATTRIBUTES
    res6 = RESERVED
    extprodid = ISVEXTNPRODID
    attEnc = ATTRIBUTES (modeling only the following 2 security-relevant flags)
      provKeyFlag = PROVISIONKEY
      debugFlag = DEBUG
    mrEnc = MRENCLAVE
    res7 = RESERVED
    mrSigner = MRSIGNER
    res8 = RESERVED
    config = CONFIGID
    prodid = ISVPRODID
    QESVN = ISVSVN
    confSVN = CONFIGSVN
    res9 = RESERVED
    famID = ISVFAMILYID
    QErdata = REPORTDATA 
  keyID = KEYID
  QEmac = MAC


* TD QE-TD LA (attestation protocol phase) *
tdr = TDREPORT_STRUCT [source: Intel Trust Domain Extensions (Intel TDX) Module Architecture Application Binary Interface (ABI) Reference Specification]
  smr = SEAMREPORT [source: Intel Trust Domain CPU Architectural Extensions (May 2021)]
    rms = REPORTMACSTRUCT
      rtyp = REPORTTYPE
      res1 = RESERVED
      csvn = CPUSVN 
      tcbh = TEE_TCB_INFO_HASH
      tdih = TEE_INFO_HASH
      rdata = REPORTDATA
      res2 = RESERVED
      mac = MAC
    tcbi = TEE_TCB_INFO
      val = VALID 
      TDXTCBSVN = TEE_TCB_SVN
      mrs = MRSEAM
      mrss = MRSIGNERSEAM
      att = SEAMATTRIBUTES
      res3 = RESERVED
  res4 = RESERVED
  tdi = TDINFO [source: Intel Trust Domain Extensions (Intel TDX) Module Architecture Application Binary Interface (ABI) Reference Specification]
    tdatt = TDATTRIBUTES
    xfam = XFAM (eXtended Features Available Mask)
    mrtd = MRTD
    mrc = MRCONFIGID
    mro = MROWNER
    mroc = MROWNERCONFIG
    rtmr = RTMR
    TODO = SERVTD_HASH (only for v1.5 feature; both local and remote attestation; exact value match with Ref Value)
    res = RESERVED

*Remote Evidence*
Quote = TD QUOTE 
  QuoteHeader 
    Version
    Attestation Key Type
    TEE Type
    RESERVED
    RESERVED
    QE Vendor ID
    User Data
  QuoteBody = TD Quote Body [source: Intel ® Trust Domain Extensions Data Center Attestation Primitives ( Intel ® TDX DCAP ): Quote Generation Library and Quote Verification Library, Rev. 0.6, February 2023]
    tcbiClaims [for artifacts only]
      TDXTCBSVN = TEE_TCB_SVN
      mrs = MRSEAM
      mrss = MRSIGNERSEAM
      att = SEAMATTRIBUTES
    tdiClaims [for artifacts only]
      tdatt = TDATTRIBUTES (modeling only the following 2 security-relevant flags)
        tudFlag = TD Under Debug flags (TUD)
        secFlag = SEC (SEPT_VE_DISABLE, PKS, KL)
      xfam = XFAM (eXtended Features Available Mask)
      mrtd = MRTD
      mrc = MRCONFIGID
      mro = MROWNER
      mroc = MROWNERCONFIG
      rtmr0 = RTMR0
      rtmr1 = RTMR1
      rtmr2 = RTMR2
      rtmr3 = RTMR3
    rdata = REPORTDATA
  AKsig
  AKcert
    pubAK
    QEReportBody
    PCKsig
    QEauthData
  PCKcert ( TODO: precise model with the following fields within PCK cert : Changes in steps: main where PCKcert is formed, step 18, 19aiii (step 16 comments only) )
    [source: Intel® SGX PCK Certificate and Certificate Revocation List Profile Specification, Rev 1.5, January 26, 2022,
    https://api.trustedservices.intel.com/documents/Intel_SGX_PCK_Certificate_CRL_Spec-1.5.pdf]
    pubPCK
    ppid = PPID 
    sgxTcbComp = SGX TCB Comp 01-16
    PCESVN = PCESVN 
    TODO = CPUSVN (Note: CPUSVN also in AKcert.QEReportBody)
    pceid = PCEID 
    fmspc = FMSPC 
    piid = PIID 
    PCAKsig
  ICAcert
    pubPCAK
    IRKsig
  rootcert
    pubIRK
    IRKselfsig

**********************************************************************
Initialization Steps (AK certification): 
**********************************************************************
I0. PCE: Generate PCK key-pair PCK = f(Processor Package/platform,HW TCB, signer of PCE, PCE SVN)
I0. QE: Generate AK key-pair (ECDSA-based) 256-bit ECC key on the P256 curve
I1. QE -> CPU: QErdata || TargetInfo
    where 
      QErdata = sha256(pubAK||QEauthData) || zeroPad [user-defined input]
        pubAK is the public part of AK [generated in step I0]
        QEauthData is obtained as input [user-defined input: assumption e] (constant in Intel's code; it identifies the vendor providing QE service. It is currently a constant string for Intel.)
          https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/master/QuoteGeneration/quote_wrapper/tdx_quote/td_ql_logic.cpp#L1383-L1385
          https://download.01.org/intel-sgx/sgx-dcap/1.16/linux/docs/Intel_TDX_DCAP_Quoting_Library_API.pdf (Sec. A.3.11 on Page 42)
        zeroPad is obtained as input
      TargetInfo = PCEinfo
I2. CPU -> QE: QEReport = QEReportBody || keyID || QEmac
    where 
      QEReportBody = CPUSVN || misc || cetAtt || res6 || extprodid || attEnc || mrEnc || res7 || mrSigner || 
                     res8 || config || prodid || QESVN || confSVN || res9 || famID || QErdata 
        All SVNs (CPUSVN, QESVN, confSVN) are obtained as input [assumption e]
        mrEnc is obtained as input [assumption e]
        QErdata as obtained from step I1
        attEnc = provKeyFlag || debugFlag
          provKeyFlag and debugFlag as inputs 
        All remaining components above are freshly generated.
      keyID is freshly generated [assumption e]
      QEmac = cmac(RK,QEReportBody)
        RK = kdfRK(keyID,TargetInfo) [Report Key]
I3. QE -> PCE: pubAK || QEReport || QEauthData
    where 
      pubAK and QEauthData as sent in step I1
      QEReport as received in step I2
I4. PCE -> CPU: Request RK (i.e., Report Key via EGETKEY)
I5. CPU -> PCE: RK 
I6. PCE: Verify QEReport based on policy:
    I6i.  MAC check, i.e., QEmac=cmac(RK, QEReportBody)?  (received MAC = computed MAC?) (sgx_verify_report)
          https://github.com/intel/linux-sgx/blob/1efe23c20e37f868498f8287921eedfbcecdc216/psw/ae/pce/pce.cpp#L282
          https://github.com/intel/linux-sgx/blob/1efe23c20e37f868498f8287921eedfbcecdc216/sdk/selib/sgx_verify_report.cpp#L100
            QEmac from QEReport as received in step I3
            QEReportBody from QEReport as received in step I3
            RK as received in step I5
    I6ii. Hash check, i.e., QErdata = sha256(pubAK||QEauthData) || zeroPadRef? (received hash = computed hash)
    I6iii.check attEnc.provKeyFlag == true 
          https://github.com/intel/linux-sgx/blob/1efe23c20e37f868498f8287921eedfbcecdc216/psw/ae/pce/pce.cpp#L286
If verified, then proceed
I7. PCE -> QE: AKcert = pubAK || QEReportBody || PCKsig || QEauthData
    where 
      pubAK and QEauthData as received in step I3
      QEReportBody from QEReport as received in step I3
      PCKsig = sign(PCK,QEReportBody)  https://github.com/intel/linux-sgx/blob/1efe23c20e37f868498f8287921eedfbcecdc216/psw/ae/pce/pce.cpp#L305C24-L305C24

**********************************************************************
Attestation Protocol Steps:
**********************************************************************
 0a. TD: Generate TDK key-pair
 0b. TD -> Verifier: pubTDK
 1. Verifier -> TD: challenge (nonce)
 2. TD -> TDX Module: rdata = sha256(pubTDK || challenge)  [user-defined input]
    where
      pubTDK as generated in step 0a
      challenge as received in step 1
 3. TDX Module: Assemble tdi from TDCS 
    where 
      tdi = tdiClaims || res5, 
        tdiClaims  = tdatt || xfam || mrtd || mrc || mro || mroc || rtmr (model as input [assumption e])
          tdatt = tudFlag || secFlag
        res5 is obtained as input
    and compute its hash: 
      tdih = sha384(tdi)
 4. TDX Module -> CPU HW: rtyp || tdih || rdata 
    where 
      rtyp is freshly generated [assumption e]
      tdih as computed in step 3
      rdata as received in step 2
 5. CPU HW: Create SEAMREPORT smr = rms || tcbi,
    where (need to compute tcbi first because its hash will be used in rms)
      tcbi = val || tcbiClaims || res3, 
        val is freshly generated
        tcbiClaims = TDXTCBSVN || mrs || mrss || att, (model as input [assumption e])
        res3 is obtained as input
      rms = rmsBody || mac,
        rmsBody = rtyp || res1 || csvn || tcbh || tdih || rdata || res2,
          rtyp, tdih and rdata as received in step 4,
          tcbh = sha384(tcbi), 
          res1 and res2 are obtained as input [assumption e],
          csvn taken as input [assumption e], and 
        mac = hmac(MK,rmsBody)
 6. CPU HW -> TDX Module: smr 
    6a. event CPUsentSMR (tcbiClaims, rdata)
        where 
          tcbiClaims from step 5 
          rdata as received in step 4
    6b. CPU HW -> TDX Module: smr
        where 
          smr as generated in step 5
 7. TDX Module: Create TDREPORT tdr = smr || res4 || tdi
    where 
      smr as received in step 6
      res4 is obtained as input [assumption e]
      tdi as generated in step 3
 8. TDX Module -> TD: tdr 
    8a. event TDXMsentTDR(tdiClaims)
        where 
          tdiClaims as generated in step 3 
    8b. TDX Module -> TD: tdr 
        where 
          tdr as generated in step 7
 9. TD -> VMM: tdr 
10. VMM -> QE: tdr 
11. QE: Check hashes: tcbh=sha384(tcbi) && tdih=sha384(tdi)?
    where 
      tcbh, tcbi, tdih and tdi as received in tdr in step 10
if hashes match then continue
12. QE -> CPU HW: rms=rmsBody || mac
    where 
      rms as received as part of tdr in step 10
13. CPU HW: verify report, i.e., mac=hmac(MK, rmsBody)? (received MAC = computed MAC?)
    where 
      mac and rmsBody as received in step 12
14. CPU HW -> QE: verification result (true/false)
if true then continue
15. QE: AKsig = sign(AK,QuoteHeader || QuoteBody)
    where 
      QuoteHeader is freshly generated [assumption e]
      QuoteBody = tcbiClaims || tdiClaims || rdata 
        tcbiClaims, tdiClaims and rdata as received as part of tdr in step 10
16. QE -> VMM: Quote= QuoteHeader || QuoteBody || AKsig || AKcert || PCKcert || ICAcert || rootcert
    where 
      QuoteHeader, QuoteBody and AKsig as generated in step 15 
      AKcert as received in initialization step I7
      PCKcert = pubPCK || sgxTcbComp || PCESVN || PCAKsig 
      ICAcert = pubPCAK || IRKsig
      rootcert = pubIRK || IRKselfsig
17. VMM -> TD: Quote 
18. TD -> Verifier: Quote 
19. Verifier: Verification of Remote Evidence
    19a. Verify X.509 cert chain for attestation (Endorsements)  
      19ai.   Verify authenticity of rootcert in TD Quote using pre-known pubIRK
      19aii.  Verify authenticity of ICAcert in TD Quote using pre-known pubIRK
      19aiii. Verify authenticity of PCKcert in TD Quote using pubPCAK in ICAcert
    19b. Verify custom cert-like structure AKcert in key hierarchy/signature chain
         i.e., verify authenticity of AKcert using pubPCK in PCKcert
                AKcert = pubAK || QEReportBody || PCKsig || QEauthData
    19c. Verify integrity of pubAK and QEauthData in AKcert
         i.e., check received QErdata = computed QErdata?
         i.e., QErdata = sha256(pubAK||QEauthDataRef) || zeroPadRef?
            QErdata as received in Step 18
            zeroPadRef symbolically represents 32 bytes of 0x00
    19d. Verify authenticity of QuoteHeader and QuoteBody using pubAK in AKcert
    19e. Verify integrity of pubTDK in QuoteBody and freshness of Quote
         i.e., check received rdata = computed rdata? [user-defined input, so match the format with sender side]
            rdata as received in Step 18
    19f. Verify claims of TD QE (in AKcert) against Reference Values based upon policy (TODO: Check signatures before using; clarify signature chain)
         based on https://api.portal.trustedservices.intel.com/documentation#pcs-enclave-identity-v4
          19fi.  Verify measurements (mrEnc) of TD QE = Reference Value of mrEnc (TODO: does not exist in implementation)
          19fii. Verify hash of ID (mrSigner) of TD QE = Reference Value of mrSigner 
          19fiii.Verify prodid of TD QE = Reference Value of prodid (always go together with 19fii)
          19fiv. Apply Reference miscMask (binary mask) to misc field in AKcert. 
                 Verify if miscMask & misc = Reference Value of misc (TODO: find important bits here) (SSA Frame extended feature set; SECS.MISCSELECT settings)
          19fv.  Apply Reference attEncMask (binary mask) to attEnc field in AKcert. 
                 Verify if attEncMask & attEnc = Reference Value of attEnc 
                 modeled only security-relevant checks: attEnc.PROVISIONKEY == 1 && attEnc.DEBUG == 0?
          19fvi. Verify received QESVN (in AKcert) >= Reference Value of QESVN (TODO: TCB levels similar to 19i)
    19g. Verify claims of TD in tdi against Reference Values based upon policy
          19gi.   Verify load-time measurements (mrtd) of TD = Reference Value of mrtd (TD owner = the one who generated the TD and gives to end-user)
                    MRTD is for the TDVF code (match PCR[0]). 
          19gii.  Verify run-time measurements (rtmr) = Reference Value of rtmr
                  [Source: Intel® TDX Virtual Firmware Design Guide (Dec. 2022)]
                  • RTMR[0] is typically for the TDVF configuration (match PCR[1,7]).
                  • RTMR[1] is typically for the TD OS loader or kernel (match PCR[4,5]).
                  • RTMR[2] is typically for the OS application (match PCR[8~15]).
                  • RTMR[3] is reserved for special usage only.
          19giii.  Verify values assigned by the creator of TD
            19giiia.Verify hash of ID (mro) of TD's owner = Reference Value assigned by the creator of TD (mroRef)
            19giiib.Verify owner-defined configurations (mroc) = Reference Value assigned by the creator of TD (mrocRef)
          19giv.  Verify non-owner-defined configurations (mrc), e.g., runtime or OS configuration = Reference Value of mrc
          19gv.   Verify TD attributes (debug and security-related are actually mandatory) 
            19gva. Verify all TD Under Debug flags are zero, i.e., tdatt.TUD = false (all software layers, so multiple debug flags)
            19gvb. Verify all security-relevant flags, i.e., tdatt.SEC, are set as expected
          19gvi.  Verify XFAM (eXtended Features Available Mask) (* TODO, not typically used, e.g., SCONE does not use it *)
    19h. Verify measurements of TDX TCB in tcbi against Reference Values based upon policy
          19hi.   Verify measurement of TDX Module (mrs) in tcbi = Reference Value of mrs
          19hii.  Verify signer ID of TDX Module (mrss) in tcbi = Reference Value of mrss
          19hiii. Verify att = Reference Value of att 
    19i. Verify TDX TCB (SVNs) against Reference Values: (>=) < means vulnerable, so mandatory: 
        order based on https://api.portal.trustedservices.intel.com/documentation#pcs-tcb-info-tdx-v4: 
          SGX TCB Comp SVNs -> PCESVN -> TEE TCB SVN (TDX Module SVN)
        19i.i.  Check received SGXTCBSVN (in PCKcert) >= Reference Value of SGXTCBSVN (SGX TCB) (component-wise checks 1-16 individually)
        19i.ii. Check received PCESVN (in PCKcert) >= Reference Value of PCESVN 
        19i.iii.Check received TDXTCBSVN (in tcbi) >= Reference Value of TDXTCBSVN (TDX TCB) (component-wise: currently only 2 bytes for TDX module SVN, can be extended in future) 
    19j. Miscellaneous based on policy 
          TODO: Tolerance for security advisories: received SGXTCBSVN (policy dependent)
          sorting: (most secure first) and then others 

Note: There is a single CPUSVN used for SGX and TDX. So CPUSVN not required as part of TD QuoteBody. 
      In experience with SGX, 16 bytes of CPUSVN always correspond to 16 bytes of SGX TCB components (1-16). That's why never checked in implementation.


If verification succeeds, then event QuoteVerified(tcbiClaims,tdiClaims,rdata) 
Architecturally-defined attestation complete. 
May have additional steps for secure session establishment (to set up session key/shared secret)
*)

(**********************************************************************)
(* Type Declarations *)
(**********************************************************************)
type MacKey.   (* mac key *)
type Hash.      (* hash *)
type SigningKey.     (* signature key *)
type VerifyingKey.     (* signature verification key *)

(**********************************************************************)
(* Declarations of functions, equational theories and rewrite rules   *)
(**********************************************************************)
(********************************************************)
(* HMAC_SHA256 *)
(********************************************************)
fun hmacSha256(MacKey, bitstring): bitstring.

(*The following destructor only if MAC is unforgeable (UF-CMA)
ONLY for adversary*)
reduc 
  forall key: MacKey, msg: bitstring; 
    get_message(hmacSha256(key, msg)) = msg.

(********************************************************)
(* Hash Functions*)
(********************************************************)

fun sha256Hash(bitstring): Hash.
fun sha384Hash(bitstring): Hash.
fun hash2bs(Hash): bitstring [typeConverter].
(*Every hash is a bitstring,  so valid converter in this direction.
In reverse direction (bitstring -> hash), use pattern matching:
let hash2bs(tcbh) = tcbi in ...
See Section 4.1.2 in manual*)

(********************************************************)
(* Public Key Signatures *)
(* Category: Digital signature schemes with appendix [HAC] *)
(* Subcategory: Deterministic [HAC]*)
(********************************************************)
fun pub(SigningKey): VerifyingKey.
fun verKey2bs(VerifyingKey): bitstring [typeConverter].

fun sign(SigningKey, bitstring): bitstring.
(*reduc forall key: SigningKey,  msg: bitstring; getmess(sign(key,msg)) = msg. Not required here for Appendix*)

(*Good practice to add function declaration for destructors also*)
(*Parameters: verification key, msg, signatures*)
fun verifySign(VerifyingKey, bitstring, bitstring): bool
reduc 
  forall key: SigningKey, msg: bitstring;
    verifySign(pub(key), msg, sign(key, msg)) = true.

(********************************************************)
(* SGX-related*)
(********************************************************)
fun kdfRK(bitstring, bitstring): MacKey.
(**********************************************************************)
(* Declarations of constants and free (vs. bound) names *)
(**********************************************************************)
free c: channel. (*Public channel*)
free c_PCE_QE: channel.
free c_PCE_Ver: channel [private]. (*Private channel*)


(* Verification Collateral: Reference Values *)
(* For simplicity, only one value is used for each Reference Value. For multiple values, use || etc. *)
(* TD QE provided by Intel *)
free mrEncRef: bitstring. (*MRENCLAVE of QE*)
free mrSignerRef: bitstring. (*MRSIGNER of QE*)
free prodidRef: bitstring. (*PRODID of QE*)

(* TDX Module provided by Intel *)
free mrsRef: bitstring. (*Measurement of TDX Module*)
free mrssRef: bitstring. (*Hash of signer of TDX Module: 0 [source: Intel ® Trust Domain Extensions Data Center Attestation Primitives ( Intel ® TDX DCAP ): Quote Generation Library and Quote Verification Library, Rev. 0.6, February 2023]*)
free attRef: bitstring. (* 0 [source: Intel ® Trust Domain Extensions Data Center Attestation Primitives ( Intel ® TDX DCAP ): Quote Generation Library and Quote Verification Library, Rev. 0.6, February 2023] *)

(* TD provided by TD Owner *)
free mrtdRef: bitstring. (* load-time measurements of TD *)
free rtmr0Ref: bitstring. (* run-time measurements of TD *)
free rtmr1Ref: bitstring. (* run-time measurements of TD *)
free rtmr2Ref: bitstring. (* run-time measurements of TD *)
free rtmr3Ref: bitstring. (* run-time measurements of TD *)
free mroRef: bitstring. (* hash of ID (mro) of TD's owner *)
free mrcRef: bitstring. (* configurations of TD *)
free mrocRef: bitstring. (* configurations of TD *)

free zeroPadRef: Hash.  (* symbolically representing the value 32-0x00's *)
free QEauthDataRef: bitstring. (* Ref Value of QEauthData *)
(* set traceDisplay = long.  Display full trace *)
(* set verboseClauses = explained. *)
(* set reconstructTrace = 100. default value of 4 led to cannot be proved for some properties; see ProVerif manual page 111 *)
(**********************************************************************)
(* Other declarations, e.g., events *)
(**********************************************************************)
event test.
event test2.
event test3.
event test4.
event test5.
event test6(bitstring).
event test7(bitstring, bitstring).
event test8.
event decSuccess.
event CPUsentSMR(bitstring, bitstring).
event TDXMsentTDR(bitstring).
event QuoteVerified(bitstring, bitstring, bitstring).
event TDidentity(VerifyingKey). 
event VerIdentity(VerifyingKey). 
event AKverified(VerifyingKey). 
event AKsent(VerifyingKey).
(********************************************************)
(* Queries *)
(********************************************************)

(********************************************************)
(* Reachability Queries *)
(********************************************************)
(* query event (test).
query event (test2).
query event (test5).
query event (decSuccess). *)
(* query event (test3).
query event (test4).
query event (test8). *)

(* step I0 *)
query pubAK: VerifyingKey; 
  event (AKverified(pubAK)).

(*Step 6*)
query tcbiClaims: bitstring, rdata: bitstring; 
  event (CPUsentSMR(tcbiClaims,rdata)).

(*Step 8*)
query tdiClaims: bitstring; 
  event (TDXMsentTDR(tdiClaims)).

(* query tdiClaims: bitstring; 
event (test6(tdiClaims)). *)

(* query tcbiClaims: bitstring, rdata: bitstring;
event (test7(tcbiClaims,rdata)). *)

(*Step 19*)
query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
  event (QuoteVerified(tcbiClaims,tdiClaims,rdata)).

query pubTDK: VerifyingKey, pubTDK_Ver: VerifyingKey;
  (event(TDidentity(pubTDK)) &&
   event(VerIdentity(pubTDK_Ver))).
(**********************************************************************)
(* Declaration of the security properties *)
(**********************************************************************)
(* query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
event (test6(tdiClaims)) ==> event (TDXMsentTDR(tdiClaims)). *)

(* query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
event (test7(tcbiClaims,rdata)) ==> event (CPUsentSMR(tcbiClaims,rdata)). *)


(********************************************************)
(* Integrity Queries *)
(********************************************************)
(* Integrity of pubAK (Init phase) *)
query pubAK: VerifyingKey; 
  event (AKverified(pubAK)) ==> event (AKsent(pubAK)).


(* Integrtiy of tcbiClaims and rdata: step 6-19 *)
query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
event (QuoteVerified(tcbiClaims,tdiClaims,rdata)) ==>
event    (CPUsentSMR(tcbiClaims,rdata)).

(*simplified query: integrity of tdiClaims: step 8-19*)
query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
event (QuoteVerified(tcbiClaims,tdiClaims,rdata)) ==> 
event (TDXMsentTDR(tdiClaims)).

(********************************************************)
(* Freshness Queries *)
(********************************************************)
query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
  event (QuoteVerified(tcbiClaims,tdiClaims,rdata)) ==>
  inj-event (CPUsentSMR(tcbiClaims,rdata)).

query tcbiClaims: bitstring, tdiClaims: bitstring, rdata: bitstring;
  event (QuoteVerified(tcbiClaims,tdiClaims,rdata)) ==> 
  inj-event (TDXMsentTDR(tdiClaims)).

(********************************************************)
(* Secrecy Query *)
(********************************************************)
(* query attacker(PCK). *)
query secret PCK.
query secret PCAK.
query secret AK.
query secret MK.

(********************************************************)
(* Authentication Queries *)
(********************************************************)
(* Authentication of TD QE (Init phase) *)
query pubAK: VerifyingKey, pubAK_PCE: VerifyingKey;
  (event(AKverified(pubAK_PCE)) &&
   event(AKsent(pubAK))) ==>
  (pubAK_PCE = pubAK).


(* Authentication of TD (Attestation protocol phase) *)
query pubTDK: VerifyingKey, pubTDK_Ver: VerifyingKey;
  (event(VerIdentity(pubTDK_Ver)) &&
   event(TDidentity(pubTDK))) ==>
  (pubTDK = pubTDK_Ver).


(**********************************************************************)
(* Declarations of the processes for each role. *)
(**********************************************************************)
let PCE(c_PCE_CPU: channel, PCK: SigningKey) = 
  (* out(c_PCE_main, PCK); pass to main *)
  in(c_PCE_QE, (pubAK_PCE: VerifyingKey, CPUSVN_PCE: nat, misc_PCE: bitstring, cetAtt_PCE: bitstring, res6_PCE: bitstring, extprodid_PCE: bitstring, provKeyFlag_PCE: bool, debugFlag_PCE: bool, mrEnc_PCE: bitstring, res7_PCE: bitstring, mrSigner_PCE: bitstring, res8_PCE: bitstring, config_PCE: bitstring, prodid_PCE: bitstring, QESVN_PCE: nat, confSVN_PCE: nat, res9_PCE: bitstring, famID_PCE: bitstring, QErdata_PCE: bitstring, keyID_PCE: bitstring, QEmac_PCE: bitstring, QEauthData_PCE: bitstring));  (*Step I3 Obtain pubAK for certification *)
  (* out(c_PCE_CPU,true);  Step I4 *)
  in(c_PCE_CPU,RK: MacKey); (*Step I5*)
  let attEnc_PCE = (provKeyFlag_PCE, debugFlag_PCE) in 
  let QEReportBody_PCE = (CPUSVN_PCE,misc_PCE,cetAtt_PCE,res6_PCE,extprodid_PCE,attEnc_PCE,mrEnc_PCE,res7_PCE,mrSigner_PCE,res8_PCE,config_PCE,prodid_PCE,QESVN_PCE,confSVN_PCE,res9_PCE,famID_PCE,QErdata_PCE) in
  if QEmac_PCE = hmacSha256(RK,QEReportBody_PCE) then (*Step I6: received MAC = computed MAC?*)  
  let QErdataPrehash = (pubAK_PCE,QEauthData_PCE) in (*for Step I6ii*)
  let QErdata = (sha256Hash(QErdataPrehash), zeroPadRef) in (*for Step I6ii*)
  if QErdata_PCE = QErdata then (*Step I6ii: received rdata = computed rdata?*)
  if provKeyFlag_PCE = true then (* Step I6iii *)
  event AKverified(pubAK_PCE);
  let PCKsig = sign(PCK,QEReportBody_PCE) in
  let AKcert = (pubAK_PCE,QEReportBody_PCE,PCKsig,QEauthData_PCE) in 
  event test4;
  out(c_PCE_QE, AKcert).  (*Step I7 AK cert*)


let QEinit(c_QE_CPU,c_QE_main: channel, PCEinfo: bitstring) =
  new AK: SigningKey;  (*Step I0 Note: generate here inside init process because used throughout*)
  let pubAK = pub(AK) in  (*Public part of attestation key*)
  event AKsent(pubAK);
  out(c, pubAK); (*Give public key to adversary*)
  in(c, QEauthData: bitstring);
  let QErdataPrehash = (pubAK,QEauthData) in (*for Step I1*)
  in(c, zeroPad: Hash);
  let QErdata = (sha256Hash(QErdataPrehash), zeroPad) in (*for Step I1*)
  let TargetInfo = PCEinfo in 
  event test;
  out (c_QE_CPU,(QErdata,TargetInfo));  (*Step I1*)
  in(c_QE_CPU,(QEReportBody_QE: bitstring, keyID_QE: bitstring, QEmac_QE: bitstring));  (*Step I2*)
  (* event test3; *)
  out(c_PCE_QE, (pubAK,QEReportBody_QE,keyID_QE,QEmac_QE,QEauthData)); (*Step I3 Send public key for certification*)  
  in(c_PCE_QE, (AKcert_QE: bitstring)); (*Step I7 AK cert*)
  out(c_QE_main, (AK,AKcert_QE)). (*AK || AK cert: pass to main*)  

let CPUinit(c_QE_CPU,c_PCE_CPU: channel, PCEinfo: bitstring) = 
  in(c_QE_CPU,(QErdata_CPU: Hash, TargetInfo_CPU: bitstring));  (*Step I1*)
  in(c,CPUSVN: nat); (*for Step I2:declaration of new names with type nat is not allowed: manual p. 39, so input from adversary*)
  in(c,QESVN: nat); (*for Step I2:declaration of new names with type nat is not allowed: manual p. 39, so input from adversary*)  
  in(c,confSVN: nat); (*for Step I2:declaration of new names with type nat is not allowed: manual p. 39, so input from adversary*)
  in(c,mrEnc: bitstring);
  in(c,mrSigner: bitstring);
  in(c,prodid: bitstring);
  new misc: bitstring;
  new cetAtt: bitstring;
  new res6: bitstring;
  new extprodid: bitstring;
  in (c, provKeyFlag: bool);
  in (c, debugFlag: bool);
  new res7: bitstring;
  new res8: bitstring;
  new config: bitstring;
  new res9: bitstring;
  new famID: bitstring;
  let attEnc = (provKeyFlag, debugFlag) in 
  let QEReportBody = (CPUSVN , misc , cetAtt , res6 , extprodid , attEnc , mrEnc , res7 , mrSigner , res8 , config , prodid , QESVN , confSVN , res9 , famID , QErdata_CPU) in  (*for Step I2*)
  new keyID: bitstring; (*[assumption e]*)
  let RK = kdfRK(keyID,TargetInfo_CPU) in 
  let QEmac = hmacSha256(RK,QEReportBody) in
  let QEReport = (QEReportBody,keyID,QEmac) in 
  event test2;
  out (c_QE_CPU,QEReport);  (*Step I2*)

  (* in(c_PCE_CPU,request:bool); (*Step I4*)
  if request = true then  *)
  event test5;
  (*Request came from PCE, so the key here is generated for PCE*)
  let RKtarget = kdfRK(keyID,PCEinfo) in 
  out (c_PCE_CPU,RKtarget). (*Step I5*)




let QE(c_QE_CPU: channel, AK: SigningKey, AKcert: bitstring, PCKcert: bitstring, ICAcert: bitstring, rootcert: bitstring) =
  in(c,(rtyp_QE: bitstring, res1_QE: bitstring, csvn_QE: nat, tcbh_QE: Hash, tdih_QE: Hash, rdata_QE: bitstring, res2_QE: bitstring, mac_QE: bitstring, val_QE: bitstring, tcbiClaims_QE: bitstring, res3_QE: bitstring, res4_QE: bitstring, tdiClaims_QE: bitstring, res5_QE: bitstring));  (*Step 10*)
  (*Note: Splitting this way in Step 10 avoids the destructors to extract*)
  let tcbi_QE = (val_QE,tcbiClaims_QE,res3_QE) in (*for Step 11*)
  let tdi_QE = (tdiClaims_QE,res5_QE) in (*for Step 11*)
  let (=tcbh_QE) = sha384Hash(tcbi_QE) in  (*Step 11: Check the hash of received tcbi_QE*)
  let (=tdih_QE) = sha384Hash(tdi_QE) in   (*Step 11: Check the hash of received tdi_QE*)
  let rmsBody_QE = (rtyp_QE,res1_QE,csvn_QE,tcbh_QE,tdih_QE,rdata_QE,res2_QE) in (*for Steps 12,15*)
  let rms_QE = (rmsBody_QE,mac_QE) in (*for Step 12*)
  out (c_QE_CPU,rms_QE); (*Step 12*)
  (*Step 12-14: Check the mac of received rms, i.e., if mac_QE = hmacSha256(MK,rmsBody_QE)*)
  in(c_QE_CPU,result:bool); (*Step 14*)
  if result = true then (*for Step 15*)
  (* event test6(tdiClaims_QE); *)
  event test7(tcbiClaims_QE,rdata_QE);  
  new QuoteHeader: bitstring;  (*for Step 15 [see assumption e]*)
  let QuoteBody = (tcbiClaims_QE,tdiClaims_QE,rdata_QE) in (* for Step 15*)
  let AKsig = sign(AK,(QuoteHeader,QuoteBody)) in (*Step 15*)
  let Quote = (QuoteHeader,QuoteBody,AKsig,AKcert,PCKcert,ICAcert,rootcert) in (*for Step 16 *)
  out(c, Quote). (*Step 16*)

(*VMM: Part of adversary*)

let TD(c_TD_TDX: channel) =
  new TDK: SigningKey;  (* Step 0a: Private part of TDK *)
  let pubTDK = pub(TDK) in  (* Step 0a: Public part of TDK *)
  out (c, pubTDK);  (* Step 0b *)

  in  (c,challenge_TD: bitstring);  (* Step 1c *)
  let rdata_prehash = (pub(TDK),challenge_TD) in (* for Step 2 *)
  let rdata = sha256Hash(rdata_prehash) in (*for Step 2 *)
  event TDidentity(pub(TDK));
  out (c_TD_TDX,rdata);  (*Step 2 rdata = hash (TD's own public key || challenge) *)
  in  (c_TD_TDX,tdr_TD: bitstring);  (*Step 8*)
  out (c,tdr_TD);  (*Step 9*)
  in  (c,Quote_TD: bitstring);  (*Step 17*)
  (* in(c,(QuoteHeader_TD: bitstring, tcbiClaims_TD: bitstring, tdiClaims_TD: bitstring, rdata_TD: bitstring, AKsig_TD: bitstring, pubAK_TD: VerifyingKey, QEReportBody_TD: bitstring, PCKsig_TD: bitstring, QEauthData_TD: bitstring));  Step 17   *)
  (* event test6(tdiClaims_TD); *)
  out (c,Quote_TD).  (*Step 18*)

let TDXModule(c_TD_TDX: channel, c_TDX_CPU: channel) =
  in(c_TD_TDX,rdata_TDX: bitstring);  (*Step 2*)
  in(c,tudFlag: bool); (*for Step 3: Get information about TD [assumption e]*)
  in(c,secFlag: bool); (*for Step 3: Get information about TD [assumption e]*)
  in(c,xfam: bitstring); (*for Step 3: Get information about TD [assumption e]*)
  in(c,mrtd: bitstring); (*for Step 3: Get information about TD [assumption e]*)
  in(c,mrc: bitstring); (*for Step 3: Get information about TD [assumption e]*)
  in(c,mro: bitstring); (*for Step 3: Get information about TD [assumption e]*)
  in(c,mroc: bitstring); (*for Step 3: Get information about TD [assumption e]*)
  in(c,rtmr0: bitstring); (*for Step 3: Get information about TD [assumption e]*)  
  in(c,rtmr1: bitstring); (*for Step 3: Get information about TD [assumption e]*)  
  in(c,rtmr2: bitstring); (*for Step 3: Get information about TD [assumption e]*)  
  in(c,rtmr3: bitstring); (*for Step 3: Get information about TD [assumption e]*) 
  let tdatt = (tudFlag, secFlag) in
  let tdiClaims = (tdatt,xfam,mrtd,mrc,mro,mroc,rtmr0,rtmr1,rtmr2,rtmr3) in 
  in(c, res5: bitstring); (*for Step 3: reserved fields [assumption e]*)
  let tdi = (tdiClaims,res5) in (* Step 3 *)
  let tdih = sha384Hash(tdi) in (*Step 3*)
  new rtyp: bitstring; (* for Step 4: Get information about report type [see assumption e]*)
  out  (c_TDX_CPU,(rtyp,tdih,rdata_TDX));  (*Step 4*)
  in(c_TDX_CPU,smr_TDX: bitstring); (*Step 6*)
  in(c, res4: bitstring); (*for Step 7 [see asssumption e]*)
  let tdr = (smr_TDX,res4,tdi) in (* Step 7 *)
  (* event TDXMsentTDR(smr_TDX,tdi);   Need all parameters rather than tdr for query *)
  event TDXMsentTDR(tdiClaims);
  out (c_TD_TDX,tdr).  (*Step 8*)

let CPUHardware(c_QE_CPU: channel, c_TDX_CPU: channel, MK: MacKey) =
  in(c_TDX_CPU,(rtyp_CPU: bitstring, tdih_CPU: Hash, rdata_CPU: bitstring));   (* step 4 *)
  in(c,TDXTCBSVN: nat); (*for Step 5*)
  in(c,mrs: bitstring); (*for Step 5*)  
  in(c,mrss: bitstring); (*for Step 5*)    
  in(c,att: bitstring); (*for Step 5*)      
  let tcbiClaims = (TDXTCBSVN,mrs,mrss,att) in 
  in(c,csvn: nat); (*for Step 5*)  
  in(c, res1: bitstring); (*for Step 5: Get missing fields of rms [see assumption e]*)
  in(c, res2: bitstring); (*for Step 5: Get missing fields of rms [see assumption e]*)
  in(c, res3: bitstring); (*for Step 5: Get missing fields of rms [see assumption e]*)
  new val: bitstring;  (*for Step 5: Get missing fields of rms [see assumption e]*)
  let tcbi = (val,tcbiClaims,res3) in (* for Step 5 *)
  let tcbh = sha384Hash(tcbi) in (* for Step 5 *)
  let rmsBody = (rtyp_CPU,res1,csvn,tcbh,tdih_CPU,rdata_CPU,res2) in (*for Step 5: Note:by forming tuple, it should convert hashes to bitstring?*)
  let mac = hmacSha256(MK,rmsBody) in (* for Step 5 *)
  let rms = (rmsBody,mac) in (* for Step 5 *)
  let smr = (rtyp_CPU,res1,csvn,tcbh,tdih_CPU,rdata_CPU,res2,mac,tcbi) in (* Step 5: smr *) 
  event CPUsentSMR(tcbiClaims,rdata_CPU); (*Basically rmsBody || mac || tcbi*)(*Need all parameters rather than smr for query*)
  out (c_TDX_CPU,smr); (*Step 6*)
  in(c_QE_CPU, (rmsBody_CPU: bitstring, mac_CPU: bitstring)); (*Step 12 note that rmsBody_CPU may be different from rmsBody because it went through untrusted VMM*)
  if mac_CPU = hmacSha256(MK,rmsBody_CPU) then (*Step 13: received MAC = computed MAC?*)
  out(c_QE_CPU,true) (*Step 14*)
  else
  out(c_QE_CPU,false). (*Step 14*)

let Verifier(pubIRK: VerifyingKey, sgxTcbComp1Ref: nat, sgxTcbComp2Ref: nat, sgxTcbComp3Ref: nat, sgxTcbComp4Ref: nat, sgxTcbComp5Ref: nat, sgxTcbComp6Ref: nat, sgxTcbComp7Ref: nat, sgxTcbComp8Ref: nat,
    sgxTcbComp9Ref: nat, sgxTcbComp10Ref: nat, sgxTcbComp11Ref: nat, sgxTcbComp12Ref: nat, sgxTcbComp13Ref: nat, sgxTcbComp14Ref: nat, sgxTcbComp15Ref: nat, sgxTcbComp16Ref: nat, PCESVNRef:nat, TDXTCBSVNRef:nat) =
  in(c,pubTDK_Ver: VerifyingKey);   (*Step 1b: can be obtained from untrusted channel since hash is protected via Quote*)
  new challenge: bitstring; (*for Step 1c*)
  out (c,challenge);  (*Step 1c:Send challenge*)
  in(c,(QuoteHeader_Ver: bitstring, 
      TDXTCBSVN_Ver: nat, mrs_Ver: bitstring, mrss_Ver: bitstring, att_Ver: bitstring,   (*tcbiClaims*)
      tudFlag_Ver: bool, secFlag_Ver: bool, xfam_Ver: bitstring, mrtd_Ver: bitstring, mrc_Ver: bitstring, mro_Ver: bitstring, mroc_Ver: bitstring, rtmr0_Ver: bitstring, rtmr1_Ver: bitstring, rtmr2_Ver: bitstring, rtmr3_Ver: bitstring,   (*tdiClaims*)
      rdata_Ver: bitstring,  (*rdata*)
      AKsig_Ver: bitstring, pubAK_Ver: VerifyingKey, CPUSVN_Ver: nat, misc_Ver: bitstring, cetAtt_Ver: bitstring, res6_Ver: bitstring, extprodid_Ver: bitstring, provKeyFlag_Ver: bool, debugFlag_Ver: bool, mrEnc_Ver: bitstring, res7_Ver: bitstring, mrSigner_Ver: bitstring, res8_Ver: bitstring, config_Ver: bitstring, prodid_Ver: bitstring, QESVN_Ver: nat, confSVN_Ver: nat, res9_Ver: bitstring, famID_Ver: bitstring, QErdata_Ver: bitstring, PCKsig_Ver: bitstring, QEauthData_Ver: bitstring, 
      pubPCK_Ver: VerifyingKey, sgxTcbComp1_Ver: nat, sgxTcbComp2_Ver: nat, sgxTcbComp3_Ver: nat, sgxTcbComp4_Ver: nat, sgxTcbComp5_Ver: nat, sgxTcbComp6_Ver: nat, sgxTcbComp7_Ver: nat, sgxTcbComp8_Ver: nat,
      sgxTcbComp9_Ver: nat, sgxTcbComp10_Ver: nat, sgxTcbComp11_Ver: nat, sgxTcbComp12_Ver: nat, sgxTcbComp13_Ver: nat, sgxTcbComp14_Ver: nat, sgxTcbComp15_Ver: nat, sgxTcbComp16_Ver: nat, PCESVN_Ver: nat, PCAKsig_Ver: bitstring,  (*PCKcert*)
      pubPCAK_Ver: VerifyingKey, IRKsig_Ver: bitstring,  (*ICAcert*)
      pubIRK_Ver: VerifyingKey, IRKselfsig_Ver: bitstring));  (*Step 18*)

  (* Step 19a *)
  if verifySign(pubIRK,verKey2bs(pubIRK_Ver),IRKselfsig_Ver) = true then (*Step 19ai: verify authenticity of rootcert*)  
  if verifySign(pubIRK,verKey2bs(pubPCAK_Ver),IRKsig_Ver) = true then (*Step 19aii: verify authenticity of ICAcert*)  
  (* pubPCAK_Ver is authentic, it can be used now *)
  let sgxTcbComp_Ver = (sgxTcbComp1_Ver, sgxTcbComp2_Ver, sgxTcbComp3_Ver, sgxTcbComp4_Ver, sgxTcbComp5_Ver, sgxTcbComp6_Ver, sgxTcbComp7_Ver, sgxTcbComp8_Ver,
    sgxTcbComp9_Ver, sgxTcbComp10_Ver, sgxTcbComp11_Ver, sgxTcbComp12_Ver, sgxTcbComp13_Ver, sgxTcbComp14_Ver, sgxTcbComp15_Ver, sgxTcbComp16_Ver) in
  if verifySign(pubPCAK_Ver,(pubPCK_Ver,sgxTcbComp_Ver,PCESVN_Ver),PCAKsig_Ver) = true then (*Step 19aiii: verify authenticity of PCKcert*)  
  (* pubPCK_Ver is authentic, it can be used now *)

  (* Step 19b *)
  let attEnc_Ver = (provKeyFlag_Ver, debugFlag_Ver) in 
  let QEReportBody_Ver = (CPUSVN_Ver,misc_Ver,cetAtt_Ver,res6_Ver,extprodid_Ver,attEnc_Ver,mrEnc_Ver,res7_Ver,mrSigner_Ver,res8_Ver,config_Ver,prodid_Ver,QESVN_Ver,confSVN_Ver,res9_Ver,famID_Ver,QErdata_Ver) in
  if verifySign(pubPCK_Ver,QEReportBody_Ver,PCKsig_Ver) = true then (*Step 19b: verify authenticity of AK cert*)

  (* Step 19c *)
  let QErdata_comp_prehash = (pubAK_Ver,QEauthDataRef) in (* for Step 19c: QErdata prehash *)
  let QErdata_comp = (sha256Hash(QErdata_comp_prehash), zeroPadRef) in (* for Step 19c: computed QErdata *)
  if (QErdata_Ver = QErdata_comp) then     (* Step 19c: received = computed? *)
  event test8;    

  (* Step 19d *)
  let tcbiClaims_Ver = (TDXTCBSVN_Ver,mrs_Ver,mrss_Ver,att_Ver) in 
  let tdatt_Ver = (tudFlag_Ver, secFlag_Ver) in
  let tdiClaims_Ver = (tdatt_Ver,xfam_Ver,mrtd_Ver,mrc_Ver,mro_Ver,mroc_Ver,rtmr0_Ver,rtmr1_Ver,rtmr2_Ver,rtmr3_Ver) in   
  let QuoteBody_Ver = (tcbiClaims_Ver,tdiClaims_Ver,rdata_Ver) in (*for Step 19d*)
  if verifySign(pubAK_Ver,(QuoteHeader_Ver,QuoteBody_Ver),AKsig_Ver) = true then (*Step 19d: verify authenticity of TD Quote*)
  event test3;
  event test6(tdiClaims_Ver);

  (* Step 19e *)
  let rdata_comp_prehash = (pubTDK_Ver,challenge) in (* for Step 19e: rdata prehash *)
  let rdata_comp = sha256Hash(rdata_comp_prehash) in (* for Step 19e: computed rdata *)
  if (rdata_Ver = hash2bs(rdata_comp)) then     (* Step 19e: freshness and public key check *)
  (* Golden value for challenge is the one which is sent *)
  (* Golden value for public key is the one in the authentic TD Quote *)
  (* If the hash of concatenation match, it means both values match *)

  (* Step 19f *)
  if (mrEnc_Ver = mrEncRef) then (* Step 19fi mrEnc of TD QE *)  
  if (mrSigner_Ver = mrSignerRef) then  (* Step 19fii mrSigner of TD QE *)
  if (prodid_Ver = prodidRef) then (* Step 19fiii prodid of TD QE *)
  if provKeyFlag_Ver = true && debugFlag_Ver = false then (* Step 19fv *) 
  in(c,QESVNRef: nat); 
  if (QESVN_Ver >= QESVNRef)  (* Step 19fvi: Check QESVN *)

  (* Step 19g *)
  && (mrtd_Ver = mrtdRef)  (* Step 19gi *)
  && (rtmr0_Ver = rtmr0Ref)  (* Step 19gii *)
  && (rtmr1_Ver = rtmr1Ref)  (* Step 19gii *)
  && (rtmr2_Ver = rtmr2Ref)  (* Step 19gii *)
  && (rtmr3_Ver = rtmr3Ref)  (* Step 19gii *)
  && (mro_Ver = mroRef)  (* Step 19giiia *)
  && (mroc_Ver = mrocRef)  (* Step 19giiib *)
  && (mrc_Ver = mrcRef)  (* Step 19giv *)
  && tudFlag_Ver = false  (* Step 19gva *)
  && secFlag_Ver = true  (* Step 19gvb *)
  (* Note: The name secFlagRef cannot be declared with the type 'bool'. Hence, taken as true for reference *)
  (* if secFlag_Ver = secFlagRef then *)

  (* Step 19h *)
  && (mrs_Ver = mrsRef)  (* Step 19hi *)
  && (mrss_Ver = mrssRef)  (* Step 19hii *)
  && (att_Ver = attRef)  (* Step 19hiii *)
  
  (* Step 19i *)
  (* Step 19i.i: Check SGXTCBSVN *)
  && (sgxTcbComp1_Ver >= sgxTcbComp1Ref) 
  && (sgxTcbComp2_Ver >= sgxTcbComp2Ref)
  && (sgxTcbComp3_Ver >= sgxTcbComp3Ref)
  && (sgxTcbComp4_Ver >= sgxTcbComp4Ref)
  && (sgxTcbComp5_Ver >= sgxTcbComp5Ref)
  && (sgxTcbComp6_Ver >= sgxTcbComp6Ref)
  && (sgxTcbComp7_Ver >= sgxTcbComp7Ref)
  && (sgxTcbComp8_Ver >= sgxTcbComp8Ref)
  && (sgxTcbComp9_Ver >= sgxTcbComp9Ref)
  && (sgxTcbComp10_Ver >= sgxTcbComp10Ref)
  && (sgxTcbComp11_Ver >= sgxTcbComp11Ref)
  && (sgxTcbComp12_Ver >= sgxTcbComp12Ref)  
  && (sgxTcbComp13_Ver >= sgxTcbComp13Ref)
  && (sgxTcbComp14_Ver >= sgxTcbComp14Ref)
  && (sgxTcbComp15_Ver >= sgxTcbComp15Ref)
  && (sgxTcbComp16_Ver >= sgxTcbComp16Ref) 

  && (PCESVN_Ver >= PCESVNRef)  (* Step 19i.ii: Check PCESVN *)

  && (TDXTCBSVN_Ver >= TDXTCBSVNRef) then (* Step 19i.iii: Check TDXTCBSVN *)

  (* pubTDK_Ver is now trustworthy *)
  event QuoteVerified(tcbiClaims_Ver,tdiClaims_Ver,rdata_Ver);
  event VerIdentity(pubTDK_Ver).

  
(**********************************************************************)
(* The main system *)
(**********************************************************************)
(* process 0 *)
set preciseActions = true. (*Required otherwise some properties cannot be proved*)

process
  new MK: MacKey; (*MAC key for smr: single MAC key is used for all TDs on same platform, so generate here*)

  (* Generate IRK and rootcert here  *)
  new IRK: SigningKey;  (*Note: generate here because need to pass public key to Verifier*)
  let pubIRK = pub(IRK) in  (*Public part of IRK*)
  let IRKselfsig = sign(IRK,verKey2bs(pubIRK)) in
  let rootcert = (pubIRK,IRKselfsig) in 
  out(c, rootcert); (*give rootcert to adversary*)

  (* Generate PCAK and ICAcert here *)
  new PCAK: SigningKey;  
  let pubPCAK = pub(PCAK) in  (*Public part of PCAK*)
  let IRKsig = sign(IRK,verKey2bs(pubPCAK)) in
  let ICAcert = (pubPCAK,IRKsig) in 
  out(c, ICAcert); (*give ICAcert to adversary*)

  (* Generate PCK and PCKcert here *)
  new PCK: SigningKey;  (*Step I0 *)
  let pubPCK = pub(PCK) in  (*Public part of PCK*)
  in(c,sgxTcbComp1: nat); 
  in(c,sgxTcbComp2: nat); 
  in(c,sgxTcbComp3: nat); 
  in(c,sgxTcbComp4: nat); 
  in(c,sgxTcbComp5: nat); 
  in(c,sgxTcbComp6: nat); 
  in(c,sgxTcbComp7: nat); 
  in(c,sgxTcbComp8: nat); 
  in(c,sgxTcbComp9: nat); 
  in(c,sgxTcbComp10: nat); 
  in(c,sgxTcbComp11: nat); 
  in(c,sgxTcbComp12: nat); 
  in(c,sgxTcbComp13: nat); 
  in(c,sgxTcbComp14: nat); 
  in(c,sgxTcbComp15: nat); 
  in(c,sgxTcbComp16: nat); 
  in(c,PCESVN: nat); 
  let sgxTcbComp = (sgxTcbComp1, sgxTcbComp2, sgxTcbComp3, sgxTcbComp4, sgxTcbComp5, sgxTcbComp6, sgxTcbComp7, sgxTcbComp8,
    sgxTcbComp9, sgxTcbComp10, sgxTcbComp11, sgxTcbComp12, sgxTcbComp13, sgxTcbComp14, sgxTcbComp15, sgxTcbComp16) in
  let PCAKsig = sign(PCAK,(pubPCK,sgxTcbComp,PCESVN)) in
  let PCKcert = (pubPCK,sgxTcbComp,PCAKsig) in 
  out(c, PCKcert); (*give PCKcert to adversary*)
  (*When PCE is untrusted, leak PCK to adversary *)
  (* out(c, PCK); *)

  new c_QE_CPUinit: channel; (*secure channel; enforced by SoC*)
  (* new c_QE_CPUinit2: channel; secure channel; enforced by SoC *)
  (* new c_PCE_QEinit: channel; Private channel  *)
  new c_PCE_CPUinit: channel; (*Private channel*)     
  new c_QE_main: channel; (*Private channel*)

  new PCEinfo: bitstring; (*To implement TargetInfo*)

  (* Initialization phase *)
  PCE(c_PCE_CPUinit,PCK) | 
  QEinit(c_QE_CPUinit,c_QE_main,PCEinfo) |  
  CPUinit(c_QE_CPUinit,c_PCE_CPUinit,PCEinfo) |
  in(c_QE_main, (AK: SigningKey, AKcert: bitstring));

  in(c,sgxTcbComp1Ref: nat); 
  in(c,sgxTcbComp2Ref: nat); 
  in(c,sgxTcbComp3Ref: nat); 
  in(c,sgxTcbComp4Ref: nat); 
  in(c,sgxTcbComp5Ref: nat); 
  in(c,sgxTcbComp6Ref: nat); 
  in(c,sgxTcbComp7Ref: nat); 
  in(c,sgxTcbComp8Ref: nat); 
  in(c,sgxTcbComp9Ref: nat); 
  in(c,sgxTcbComp10Ref: nat); 
  in(c,sgxTcbComp11Ref: nat); 
  in(c,sgxTcbComp12Ref: nat); 
  in(c,sgxTcbComp13Ref: nat); 
  in(c,sgxTcbComp14Ref: nat); 
  in(c,sgxTcbComp15Ref: nat); 
  in(c,sgxTcbComp16Ref: nat); 
  in(c,PCESVNRef: nat);
  in(c,TDXTCBSVNRef: nat);

  (* Attestation protocol phase  *)
  (*The trace will have the processes in the following order*)
  ( ! ( new c_QE_CPU: channel; new c_TDX_CPU: channel; new c_TD_TDX: channel;  
      ( QE(c_QE_CPU,AK,AKcert,PCKcert,ICAcert,rootcert) |  TD(c_TD_TDX) | 
      TDXModule(c_TD_TDX,c_TDX_CPU) | CPUHardware(c_QE_CPU,c_TDX_CPU,MK)  ) ) |
  (!Verifier(pub(IRK), sgxTcbComp1Ref, sgxTcbComp2Ref, sgxTcbComp3Ref, sgxTcbComp4Ref, sgxTcbComp5Ref, sgxTcbComp6Ref, sgxTcbComp7Ref, sgxTcbComp8Ref,
    sgxTcbComp9Ref, sgxTcbComp10Ref, sgxTcbComp11Ref, sgxTcbComp12Ref, sgxTcbComp13Ref, sgxTcbComp14Ref, sgxTcbComp15Ref, sgxTcbComp16Ref, PCESVNRef, TDXTCBSVNRef)) )
